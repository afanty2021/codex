# 会话管理

<cite>
**本文档中引用的文件**  
- [thread.ts](file://sdk/typescript/src/thread.ts)
- [threadOptions.ts](file://sdk/typescript/src/threadOptions.ts)
- [codex.ts](file://sdk/typescript/src/codex.ts)
- [exec.ts](file://sdk/typescript/src/exec.ts)
- [events.ts](file://sdk/typescript/src/events.ts)
- [items.ts](file://sdk/typescript/src/items.ts)
- [basic_streaming.ts](file://sdk/typescript/samples/basic_streaming.ts)
- [run.test.ts](file://sdk/typescript/tests/run.test.ts)
- [runStreamed.test.ts](file://sdk/typescript/tests/runStreamed.test.ts)
</cite>

## 目录
1. [简介](#简介)
2. [会话创建与启动](#会话创建与启动)
3. [ThreadOptions 配置](#threadoptions-配置)
4. [消息管理与会话历史](#消息管理与会话历史)
5. [会话状态管理](#会话状态管理)
6. [会话生命周期管理](#会话生命周期管理)
7. [实际应用示例](#实际应用示例)
8. [事件处理机制](#事件处理机制)

## 简介
Codex TypeScript SDK 提供了强大的会话管理功能，允许开发者创建、管理和操作与 AI 代理的对话会话。本文档详细解释了 `Thread` 类的创建、管理和操作，包括如何使用 `createThread()` 方法启动新会话，以及 `ThreadOptions` 中与会话相关的配置。文档还描述了如何向现有会话添加消息、检索会话历史记录以及管理会话状态，并提供实际示例展示如何在应用中持久化会话 ID、恢复之前的对话以及处理会话生命周期。

**Section sources**
- [codex.ts](file://sdk/typescript/src/codex.ts#L6-L10)

## 会话创建与启动

### Thread 类的创建
在 Codex TypeScript SDK 中，会话通过 `Thread` 类来表示。`Thread` 类代表与 AI 代理的一系列对话，一个会话可以包含多个连续的回合（turn）。会话的创建主要通过 `Codex` 类的 `startThread()` 方法完成。

```mermaid
classDiagram
class Codex {
+startThread(options : ThreadOptions) : Thread
+resumeThread(id : string, options : ThreadOptions) : Thread
}
class Thread {
-_exec : CodexExec
-_options : CodexOptions
-_id : string | null
-_threadOptions : ThreadOptions
+id : string | null
+runStreamed(input : Input, turnOptions : TurnOptions) : Promise<StreamedTurn>
+run(input : Input, turnOptions : TurnOptions) : Promise<Turn>
}
class CodexExec {
+run(args : CodexExecArgs) : AsyncGenerator<string>
}
Codex --> Thread : "创建"
Thread --> CodexExec : "执行"
```

**Diagram sources**
- [codex.ts](file://sdk/typescript/src/codex.ts#L11-L39)
- [thread.ts](file://sdk/typescript/src/thread.ts#L41-L138)
- [exec.ts](file://sdk/typescript/src/exec.ts#L42-L192)

### 启动新会话
要启动一个新会话，首先需要创建 `Codex` 实例，然后调用其 `startThread()` 方法。该方法返回一个 `Thread` 实例，可用于与 AI 代理进行交互。

```mermaid
sequenceDiagram
participant Application
participant Codex
participant Thread
participant CodexExec
Application->>Codex : new Codex(options)
Codex->>Thread : startThread(options)
Thread->>CodexExec : 构造执行参数
Codex->>Application : 返回 Thread 实例
```

**Diagram sources**
- [codex.ts](file://sdk/typescript/src/codex.ts#L15-L26)
- [thread.ts](file://sdk/typescript/src/thread.ts#L53-L63)

**Section sources**
- [codex.ts](file://sdk/typescript/src/codex.ts#L20-L26)
- [thread.ts](file://sdk/typescript/src/thread.ts#L53-L63)

## ThreadOptions 配置

### 会话配置选项
`ThreadOptions` 接口定义了会话的各种配置选项，允许开发者根据具体需求定制会话行为。这些选项在创建会话时通过 `startThread()` 或 `resumeThread()` 方法传递。

```mermaid
classDiagram
class ThreadOptions {
+model? : string
+sandboxMode? : SandboxMode
+workingDirectory? : string
+skipGitRepoCheck? : boolean
+modelReasoningEffort? : ModelReasoningEffort
+networkAccessEnabled? : boolean
+webSearchEnabled? : boolean
+approvalPolicy? : ApprovalMode
+additionalDirectories? : string[]
}
class SandboxMode {
+read-only
+workspace-write
+danger-full-access
}
class ModelReasoningEffort {
+minimal
+low
+medium
+high
}
class ApprovalMode {
+never
+on-request
+on-failure
+untrusted
}
ThreadOptions --> SandboxMode : "包含"
ThreadOptions --> ModelReasoningEffort : "包含"
ThreadOptions --> ApprovalMode : "包含"
```

**Diagram sources**
- [threadOptions.ts](file://sdk/typescript/src/threadOptions.ts#L7-L17)

### 配置选项详解
`ThreadOptions` 中的每个配置选项都有特定的用途：

- **model**: 指定使用的 AI 模型名称
- **sandboxMode**: 定义沙箱模式，控制代理的执行权限
- **workingDirectory**: 设置工作目录
- **skipGitRepoCheck**: 是否跳过 Git 仓库检查
- **modelReasoningEffort**: 控制模型推理努力程度
- **networkAccessEnabled**: 是否启用网络访问
- **webSearchEnabled**: 是否启用网络搜索
- **approvalPolicy**: 定义审批策略
- **additionalDirectories**: 指定额外的目录访问权限

这些配置选项在会话创建时被传递给底层的 `CodexExec` 实例，并最终转换为命令行参数传递给核心执行程序。

```mermaid
flowchart TD
Start([创建会话]) --> Configure["配置 ThreadOptions"]
Configure --> Validate["验证配置选项"]
Validate --> Transform["转换为命令行参数"]
Transform --> Execute["执行 codex exec 命令"]
Execute --> End([会话启动])
subgraph "配置转换"
Transform --> Model["--model <model>"]
Transform --> Sandbox["--sandbox <sandboxMode>"]
Transform --> WorkingDir["--cd <workingDirectory>"]
Transform --> SkipGit["--skip-git-repo-check"]
Transform --> Reasoning["--config model_reasoning_effort=<value>"]
Transform --> Network["--config sandbox_workspace_write.network_access=<bool>"]
Transform --> WebSearch["--config features.web_search_request=<bool>"]
Transform --> Approval["--config approval_policy=<value>"]
Transform --> AdditionalDirs["--add-dir <dir> (多次)"]
end
```

**Diagram sources**
- [exec.ts](file://sdk/typescript/src/exec.ts#L8-L37)
- [threadOptions.ts](file://sdk/typescript/src/threadOptions.ts#L7-L17)

**Section sources**
- [threadOptions.ts](file://sdk/typescript/src/threadOptions.ts#L7-L17)
- [exec.ts](file://sdk/typescript/src/exec.ts#L51-L108)

## 消息管理与会话历史

### 添加消息到会话
向会话添加消息是通过 `Thread` 类的 `run()` 和 `runStreamed()` 方法实现的。这两个方法都接受输入内容并将其发送给 AI 代理进行处理。

```mermaid
sequenceDiagram
participant User
participant Application
participant Thread
participant CodexExec
participant AI
User->>Application : 提供输入
Application->>Thread : run(input, turnOptions)
Thread->>CodexExec : run(args)
CodexExec->>AI : 发送请求
AI-->>CodexExec : 返回事件流
CodexExec-->>Thread : 生成事件
Thread-->>Application : 返回结果
Application-->>User : 显示响应
```

**Diagram sources**
- [thread.ts](file://sdk/typescript/src/thread.ts#L66-L137)
- [exec.ts](file://sdk/typescript/src/exec.ts#L51-L192)

### 输入类型处理
SDK 支持多种输入类型，包括纯文本和本地图片。`Input` 类型定义了可以传递给 `run()` 和 `runStreamed()` 方法的输入格式。

```mermaid
classDiagram
class Input {
<<union>>
}
class UserInput {
<<union>>
}
class TextInput {
+type : "text"
+text : string
}
class ImageInput {
+type : "local_image"
+path : string
}
Input --> string : "字符串"
Input --> UserInput[] : "用户输入数组"
UserInput --> TextInput : "文本输入"
UserInput --> ImageInput : "图片输入"
```

**Diagram sources**
- [thread.ts](file://sdk/typescript/src/thread.ts#L28-L38)
- [thread.ts](file://sdk/typescript/src/thread.ts#L140-L154)

### 会话历史检索
会话历史通过事件流的形式提供。每次调用 `run()` 或 `runStreamed()` 方法时，SDK 都会生成一系列事件，这些事件构成了会话的历史记录。

```mermaid
flowchart TD
A[开始回合] --> B[生成事件流]
B --> C{事件类型}
C --> |thread.started| D["设置会话ID (thread_id)"]
C --> |turn.started| E["回合开始"]
C --> |item.started| F["项目开始"]
C --> |item.updated| G["项目更新"]
C --> |item.completed| H["项目完成"]
C --> |turn.completed| I["回合完成 (包含使用情况)"]
C --> |turn.failed| J["回合失败 (包含错误)"]
C --> |error| K["流错误"]
H --> L{项目类型}
L --> |agent_message| M["代理消息"]
L --> |reasoning| N["推理"]
L --> |command_execution| O["命令执行"]
L --> |file_change| P["文件变更"]
L --> |mcp_tool_call| Q["MCP工具调用"]
L --> |web_search| R["网络搜索"]
L --> |todo_list| S["待办事项"]
L --> |error| T["错误"]
```

**Diagram sources**
- [events.ts](file://sdk/typescript/src/events.ts#L6-L81)
- [items.ts](file://sdk/typescript/src/items.ts#L9-L128)

**Section sources**
- [events.ts](file://sdk/typescript/src/events.ts#L6-L81)
- [items.ts](file://sdk/typescript/src/items.ts#L9-L128)

## 会话状态管理

### 会话ID管理
会话ID是会话的核心标识符，用于在不同时间点恢复和继续会话。会话ID在第一个回合开始时由系统生成，并通过 `thread.started` 事件提供。

```mermaid
sequenceDiagram
participant Thread
participant Event
participant ID
Thread->>Event : 监听事件流
Event->>Thread : thread.started 事件
Thread->>ID : 提取 thread_id
ID->>Thread : 设置 _id 属性
Thread->>Thread : id 属性可访问
```

**Diagram sources**
- [thread.ts](file://sdk/typescript/src/thread.ts#L103-L105)

### 状态转换
会话在其生命周期中会经历多种状态转换，这些状态通过不同的事件类型来表示。

```mermaid
stateDiagram-v2
[*] --> Idle
Idle --> Active : run() 或 runStreamed()
Active --> Processing : 接收事件
Processing --> Idle : 回合完成
Processing --> Error : 回合失败
Error --> Idle : 处理错误
Active --> Idle : 所有处理完成
note right of Active
会话处于活动状态，
正在处理输入
end note
note right of Processing
正在接收和处理
事件流
end note
note right of Idle
会话空闲，
等待新输入
end note
```

**Diagram sources**
- [thread.ts](file://sdk/typescript/src/thread.ts#L66-L137)

**Section sources**
- [thread.ts](file://sdk/typescript/src/thread.ts#L47-L50)
- [events.ts](file://sdk/typescript/src/events.ts#L6-L81)

## 会话生命周期管理

### 会话持久化
会话在本地文件系统中持久化存储，允许在应用程序重启后恢复之前的对话。会话数据存储在用户主目录下的 `~/.codex/sessions` 目录中。

```mermaid
flowchart TD
A[创建会话] --> B[生成会话ID]
B --> C[开始第一个回合]
C --> D[接收 thread.started 事件]
D --> E[存储会话元数据]
E --> F[写入 ~/.codex/sessions/ 目录]
F --> G[会话持久化完成]
H[恢复会话] --> I[提供会话ID]
I --> J[调用 resumeThread()]
J --> K[传递会话ID给 exec]
K --> L[exec 恢复会话状态]
L --> M[会话恢复完成]
```

**Diagram sources**
- [codex.ts](file://sdk/typescript/src/codex.ts#L30-L37)
- [exec.ts](file://sdk/typescript/src/exec.ts#L105-L107)

### 会话恢复
通过 `Codex` 类的 `resumeThread()` 方法可以恢复之前的会话。该方法接受会话ID作为参数，并创建一个与指定会话关联的 `Thread` 实例。

```mermaid
sequenceDiagram
participant Application
participant Codex
participant Thread
participant CodexExec
Application->>Codex : resumeThread(id, options)
Codex->>Thread : new Thread(exec, options, options, id)
Thread->>CodexExec : run(args) 其中 args.threadId = id
CodexExec->>System : codex exec resume <id>
System-->>CodexExec : 恢复会话状态
CodexExec-->>Thread : 返回事件流
Thread-->>Codex : 返回 StreamedTurn
Codex-->>Application : 返回 Thread 实例
```

**Diagram sources**
- [codex.ts](file://sdk/typescript/src/codex.ts#L35-L37)
- [exec.ts](file://sdk/typescript/src/exec.ts#L105-L107)

### 会话关闭与删除
虽然 SDK 本身不提供显式的会话关闭或删除方法，但会话的生命周期管理通过底层系统的会话管理机制实现。会话在长时间不活动后可能会被系统自动清理。

```mermaid
flowchart TD
A[会话创建] --> B[会话使用]
B --> C{会话状态}
C --> |活跃| D[持续使用]
C --> |非活跃| E[标记为可清理]
E --> F{是否在保护列表中}
F --> |是| G[保留会话]
F --> |否| H[终止会话]
H --> I[删除会话文件]
I --> J[会话完全删除]
D --> C
```

**Diagram sources**
- [session_manager.rs](file://codex-rs/core/src/unified_exec/session_manager.rs#L601-L646)

**Section sources**
- [codex.ts](file://sdk/typescript/src/codex.ts#L35-L37)
- [exec.ts](file://sdk/typescript/src/exec.ts#L105-L107)

## 实际应用示例

### 基本会话流程
以下示例展示了如何使用 Codex TypeScript SDK 创建和管理会话的基本流程。

```mermaid
flowchart TD
A[导入 SDK] --> B[创建 Codex 实例]
B --> C[启动新会话]
C --> D[发送消息]
D --> E{处理响应}
E --> |流式处理| F[逐个处理事件]
E --> |完整处理| G[等待完整响应]
F --> H[根据事件类型处理]
G --> I[处理完整结果]
H --> J[显示代理响应]
H --> K[显示推理过程]
H --> L[显示命令执行]
H --> M[显示文件变更]
I --> J
J --> N{继续会话?}
N --> |是| D
N --> |否| O[结束]
```

**Section sources**
- [basic_streaming.ts](file://sdk/typescript/samples/basic_streaming.ts#L1-L91)

### 会话恢复示例
以下示例展示了如何持久化会话ID并在后续恢复会话。

```mermaid
sequenceDiagram
participant App1 as 应用实例1
participant App2 as 应用实例2
participant Codex
participant Thread
participant Storage as 存储
App1->>Codex : startThread()
Codex->>Thread : 创建新会话
Thread->>App1 : 返回 Thread 实例
App1->>Thread : run("Hello")
Thread->>App1 : 返回响应
App1->>Storage : 保存 thread.id
Storage-->>App1 : 保存完成
App2->>Storage : 读取保存的会话ID
Storage-->>App2 : 返回会话ID
App2->>Codex : resumeThread(id)
Codex->>Thread : 创建恢复会话
Thread->>App2 : 返回 Thread 实例
App2->>Thread : run("Continue")
Thread->>App2 : 返回响应
```

**Section sources**
- [run.test.ts](file://sdk/typescript/tests/run.test.ts#L141-L185)
- [runStreamed.test.ts](file://sdk/typescript/tests/runStreamed.test.ts#L113-L158)

## 事件处理机制

### 事件类型
SDK 定义了多种事件类型，用于表示会话中的不同状态和操作。

```mermaid
classDiagram
class ThreadEvent {
<<union>>
}
class ThreadStartedEvent {
+type : "thread.started"
+thread_id : string
}
class TurnStartedEvent {
+type : "turn.started"
}
class TurnCompletedEvent {
+type : "turn.completed"
+usage : Usage
}
class TurnFailedEvent {
+type : "turn.failed"
+error : ThreadError
}
class ItemStartedEvent {
+type : "item.started"
+item : ThreadItem
}
class ItemUpdatedEvent {
+type : "item.updated"
+item : ThreadItem
}
class ItemCompletedEvent {
+type : "item.completed"
+item : ThreadItem
}
class ThreadErrorEvent {
+type : "error"
+message : string
}
ThreadEvent --> ThreadStartedEvent
ThreadEvent --> TurnStartedEvent
ThreadEvent --> TurnCompletedEvent
ThreadEvent --> TurnFailedEvent
ThreadEvent --> ItemStartedEvent
ThreadEvent --> ItemUpdatedEvent
ThreadEvent --> ItemCompletedEvent
ThreadEvent --> ThreadErrorEvent
```

**Diagram sources**
- [events.ts](file://sdk/typescript/src/events.ts#L6-L81)

### 项目类型
事件中的项目可以是多种类型，每种类型代表不同的操作或响应。

```mermaid
classDiagram
class ThreadItem {
<<union>>
}
class AgentMessageItem {
+id : string
+type : "agent_message"
+text : string
}
class ReasoningItem {
+id : string
+type : "reasoning"
+text : string
}
class CommandExecutionItem {
+id : string
+type : "command_execution"
+command : string
+aggregated_output : string
+exit_code? : number
+status : CommandExecutionStatus
}
class FileChangeItem {
+id : string
+type : "file_change"
+changes : FileUpdateChange[]
+status : PatchApplyStatus
}
class McpToolCallItem {
+id : string
+type : "mcp_tool_call"
+server : string
+tool : string
+arguments : unknown
+result? : {content : McpContentBlock[], structured_content : unknown}
+error? : {message : string}
+status : McpToolCallStatus
}
class WebSearchItem {
+id : string
+type : "web_search"
+query : string
}
class TodoListItem {
+id : string
+type : "todo_list"
+items : TodoItem[]
}
class ErrorItem {
+id : string
+type : "error"
+message : string
}
ThreadItem --> AgentMessageItem
ThreadItem --> ReasoningItem
ThreadItem --> CommandExecutionItem
ThreadItem --> FileChangeItem
ThreadItem --> McpToolCallItem
ThreadItem --> WebSearchItem
ThreadItem --> TodoListItem
ThreadItem --> ErrorItem
```

**Diagram sources**
- [items.ts](file://sdk/typescript/src/items.ts#L9-L128)

**Section sources**
- [events.ts](file://sdk/typescript/src/events.ts#L6-L81)
- [items.ts](file://sdk/typescript/src/items.ts#L9-L128)